"""
一种奇怪的移动石头的游戏，问最少、最多多少步游戏可以结束。

游戏结束的条件是三块石头的相邻。每一步只能选取最左边或者最右边的石头，并且只能向中间移动。比如假设三块石头的位置是 ``x, y, z`` 并且 ``x < y < z`` ，只能选取最左边的x或者最右边的z，移动到区间 ``(x, z)`` 之间的某个位置（且不等于y）。

分情况讨论一下

-   如果一开始三块石头就是相邻的，那么啥也不用做
-   如果一开始其中两块石头是相邻的，而第三块石头没有相邻，那么最少的步数就是1步（直接把远处的石头搬过来就可以了），最多的步数是远处的石头每次只移动一格需要的步数
-   如果三块石头互相都不相邻

    这种情况复杂一点，而且很容易漏掉情况

    -   如果有两块石头的位置只相差2，这时候最小步数是1，最大步数是最左边和最右边两块石头每次只移动一格、慢慢移到中间石头的两边所需的步数

        这种情况容易忽略。比如 ``1, 3, 6`` ，最快的方法其实是直接把6移动到2。

    -   否则，最小步数是2（左边的石头一步移动到中间石头紧邻的左边、右边的石头一步移动到中间石头紧邻的右边），最大步数是左边的石头每次只移动一步慢慢移动到中间石头的左边、加上右边的石头每次只移动一步慢慢移动到中间石头的右边所需的步数
"""

from typing import *

class Solution:
    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
        a, b, c = sorted([a, b, c]) # 先从小到大排序
        if a == b - 1 and b == c - 1: # 三块石头一开始就是相邻的
            return [0, 0] # 直接0, 0
        elif a == b - 1 and b < c - 1: # 左边两块石头是相邻的，右边的石头在远处
            return [1, c - b - 1] # 最快1步，最慢就是右边远处的石头每次只移动一步，慢慢向左移动过来
        elif a < b - 1 and b == c - 1: # 右边两块石头是相邻的，左边的石头在远处
            return [1, b - a - 1] # 同理
        else: # 三块石头两两不相邻
            if a == b - 2 or b == c - 2: # 左边的两块石头位置只相差2、或者右边的两块石头位置只相差2
                return [1, b - a - 1 + c - b - 1] # 最快是1步，直接把远处的石头插入到这两块石头中间
            else:
                return [2, b - a - 1 + c - b - 1]

# s = Solution()
# print(s.numMovesStones(1, 2, 5)) # [1, 2]
# print(s.numMovesStones(4, 3, 2)) # [0, 0]
# print(s.numMovesStones(1, 3, 5)) # [1, 2]