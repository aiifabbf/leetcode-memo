/*
.. default-role:: math

一年中有几天要坐火车出行，票有三种选择，一种是单日票，一种是7日票，一种是30日票。问最少花费是多少。

比如给 ``[1, 4, 6, 7, 8, 20]`` 表示在第1、4、6、7、8、20天需要出行，单日票的票价是2快、7日票是7块、30日票是15快，那么最少需要11块就够了，怎么安排呢？

-   在第1天的时候买一张7日票，可以管1、4、6、7
-   在第8天的时候买一张单日票，可以管8
-   在第20天的时候买一张单日票，可以管20

总共花费是11元。

直觉告诉我应该用DP。设 ``dp[j]`` 是前 `j` 天的最少花费，那么最终答案是 ``dp[365]`` 。那么 ``dp[j]`` 和前面的项有什么关系呢？或者说已知前 `j` 天的最小花费，怎么算出第 `j` 天的最小花费呢？

-   如果第 `j - 1` 天不出行，那么啥也不用做，不用买票。所以 ``dp[j] == dp[j - 1]``
-   如果第 `j - 1` 天要出行，那么需要买票，可是应该买哪种票呢？三种选择

    -   可以在第 `j - 1` 天买单日票，总花费是单日票价 + ``dp[j - 1]``
    -   可以在 `[j - 7, j)` 中任意一天买一张7日票，总花费是7日票价 + ``min(dp[j - 7], dp[j - 6], dp[j - 5], ..., dp[j - 1])``
    -   可以在 `[j - 30, j)` 中任意一天买一张30日票，总花费是30日票价 + ``min(dp[j - 30], dp[j - 29], dp[j - 29], ..., dp[j - 1])``

这样已经足够优化了。

还可以再究极优化：观察到一件事情， ``dp`` 是单调（非严格）递增的，所以 ``min(dp[j - 7], dp[j - 6], dp[j - 5], ..., dp[j - 1])`` 必定等于 ``dp[j - 7]`` ，同理 ``min(dp[j - 30], dp[j - 29], dp[j - 29], ..., dp[j - 1])`` 也必定等于 ``dp[j - 30]`` 。

等于说买7日票的最小花费一定是第 `j - 7` 天买一张7日票，然后管到第 `j - 1` 天。
*/

struct Solution;

use std::collections::HashSet;

impl Solution {
    pub fn mincost_tickets(days: Vec<i32>, costs: Vec<i32>) -> i32 {
        let days: HashSet<usize> = days.into_iter().map(|v| v as usize - 1).collect(); // 哪几天要出行
        let mut dp = [0; 366];

        for j in 1..366 {
            if days.contains(&(j - 1)) {
                // 第j - 1天要出行
                dp[j] = (costs[0] + dp[j - 1]) // 买单日票
                    .min(costs[1] + dp[j.checked_sub(7).unwrap_or(0)]) // 买7日票
                    .min(costs[2] + dp[j.checked_sub(30).unwrap_or(0)]); // 买30日票
            } else {
                // 如果第j - 1天根本不出行
                dp[j] = dp[j - 1]; // 啥也不买
            }
        }

        return dp[365]; // 前365天的最小花费，当然就是最终答案
    }
}

fn main() {
    dbg!(Solution::mincost_tickets(
        vec![1, 4, 6, 7, 8, 20],
        vec![2, 7, 15]
    )); // 11
    dbg!(Solution::mincost_tickets(
        vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31],
        vec![2, 7, 15]
    )); // 17
}
