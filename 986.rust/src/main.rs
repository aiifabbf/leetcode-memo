/*
.. default-role:: math

给两个人的空闲时间列表，列表里面都是左闭右闭的区间，表示这个人在这个时间段里有空，问两个人同时都有空的时间区间是哪些。

比如第一个人12点到13点、14点到15点有空，第二个人12点到15点都有空，那么他们共同的空闲时间就是12点到13点、14点到15点。

完全对称的双指针，比较第一个人的第 `i` 个空闲区间和第二个人的第 `j` 个空闲区间，根据情况算出交集、再自增 `i` 或者自增 `j` 。两个左闭右闭的空闲区间算下来总共有7种情况

-   `i` 区间在 `j` 区间的前面，两个区间没有交集

    ::

        |----|
                |----|

    这时候两个区间没有交集，所以不用计算什么交集，因为根本没有交集。

    这时候应该自增 `i` 还是自增 `j` 呢？

    当然应该是自增 `i` ，因为说不定第 `i + 1` 个区间和第 `j` 个区间有交集呢？比如这样

    ::

        |----| |----|
                |----|

    实在想不通的话，可以用排除法。现在 `i` 区间在 `j` 区间前面，而且没有交集。如果这时候自增 `j` 了，那么 `i` 区间和 `j + 1` 区间更不可能有交集了。所以这时候只可能自增 `i` 。

-   `j` 区间在 `i` 区间的前面，两个区间没有交集

    和上面一种情况是完全对称的情况

    ::

                |----|
        |----|

    同理，这时候应该自增 `j` 。

-   `i` 区间完全包含 `j` 区间

    ::

        |------------|
          |----|

    这时候有交集了，交集就是 `[两个起始时间的最大值, 两个终止时间的最小值]` 。

    那么这时候应该动 `i` 还是动 `j` 呢？应该动 `i` ，因为说不定 `j + 1` 区间就会和 `i` 区间仍然有交集，就像这样

    ::

        |------------|
          |----| |----|

-   `j` 区间完全包含 `i` 区间

    ::

          |----|
        |------------|

    和上面一种情况也是对称的。算出交集之后应该动 `i` 。

-   `i` 区间在 `j` 区间前面，没有包含关系，但是有交集

    ::

        |----|
          |--------|

    交集仍然是 `[两个起始时间的最大值, 两个终止时间的最小值]` 。

    自增 `i` ，因为说不定第 `i + 1` 个区间就会和 `j` 区间有交集，比如

    ::

        |----| |----|
          |--------|

-   `j` 区间在 `i` 区间前面，没有包含关系，但是有交集

    ::

          |--------|
        |----|

    和上面是对称的情况。计算出交集之后，自增 `j` 。

-   `i` 区间和 `j` 区间完全相同

    ::

        |----|
        |----|

    交集就是本身。同时自增 `i` 和 `j` 。

    当然也可以当做特殊的包含情况。

7种情况也太多了，可以合并一下。观察上面的7种情况，其实还会发现

-   有没有交集和 `i` 区间在前面还是 `j` 区间在前面完全没有关系，完全就取决于它们的大小和相对位置。
-   自增 `i` 还是自增 `j` 完全取决于 `i` 区间的结束时间更早还是 `j` 区间的结束时间更早。如果 `i` 区间的结束时间更早，那么就自增 `i` ；如果 `j` 区间的结束时间更早，那么就自增 `j` 。
*/

struct Solution;

use std::cmp::max;
use std::cmp::min;

impl Solution {
    pub fn interval_intersection(a: Vec<Vec<i32>>, b: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut res = vec![];
        let mut a = &a[..];
        let mut b = &b[..];

        while (!a.is_empty()) && (!b.is_empty()) {
            let v = &a[0]; // 第一个人目前最早的空闲区间
            let w = &b[0]; // 第二个人目前最早的空闲区间

            if v[1] < w[0] {
                // v区间在w区间的前面，同时两个区间没有交集
                // 因为空闲区间是左闭右闭的，所以这边是小于，如果是左闭右开的话，要改成小于等于
                a = &a[1..]; // 直接看第一个人的下一个空闲区间
            } else if w[1] < v[0] {
                // 和上面完全对称的情况，w区间在v区间的前面，同时两个区间没有交集
                b = &b[1..]; // 直接看第二个人的下一个空闲区间
            } else {
                // 不然就是两个区间有交集
                res.push(vec![max(v[0], w[0]), min(v[1], w[1])]); // 取相交的部分
                if v[1] < w[1] {
                    // 如果v区间结束的比w区间早，那么应该看v区间的下一个区间，说不定下一个区间和w区间仍然有交集
                    a = &a[1..];
                } else if w[1] < v[1] {
                    b = &b[1..];
                } else {
                    // 结束时间相同的话，两个同时往后看
                    a = &a[1..];
                    b = &b[1..];
                }
            }
        }

        return res;
    }
}

fn main() {
    dbg!(Solution::interval_intersection(
        vec![vec![0, 2], vec![5, 10], vec![13, 23], vec![24, 25],],
        vec![vec![1, 5], vec![8, 12], vec![15, 24], vec![25, 26],]
    )); // [1, 2], [5, 5], [8, 10], [15, 23], [24, 24], [25, 25]
}
