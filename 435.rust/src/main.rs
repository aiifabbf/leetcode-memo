/*
.. default-role:: math

给 `n` 个左闭右开的时间区间 `A = \{[a_i, b_i)\}` ，找到 `A` 的一个最大子集，使得这个子集里面的任意两个时间区间互相不冲突

当然题目不是直接叫你算这个，原题是让你算最少要删掉多少个区间才能使集合里任意两个时间区间不冲突。一样的道理，算出最大子集的大小，减掉就可以了。

这个问题有各种翻版、各种故事背景。最著名的是会议室安排问题：你只有一间会议室，所以任意时间只能有一场会议在开，问你最多可以安排多少场会议。或者是这一天有好几个活动，你不能一次参加两个活动，最多能去多少个活动。

还有一个变体是机器赚钱的问题：你只有一台机器，机器上任意时间只能跑一个任务，每个任务跑完能赚一些钱，问最多可以赚多少钱。

还有一个类似的问题是反过来问：给你很多会议的时间，要全部举办，最少需要多少间会议室。这是253题（突然发现变成要氪金才能看了，垃圾leetcode）。或者是小明要上好多辅导班，他最少要一心几用。或者是有一堆任务，最少需要多少台机器。

这里用了DP，而且和Python版里的定义不一样。我觉得更好理解一点。先把区间按照结束时间从小到大排序，这样才能满足这样一种性质：对于第 `j` 个会议，如果我们能在它前面找到一个会议 `i < j` ，使得会议 `j` 和会议 `i` 不冲突，那么我们一定能保证会议 `i - 1` 和会议 `j` 也不冲突。为什么呢？因为会议 `j` 和会议 `i` 不冲突等价于会议 `i` 的结束时间小于等于（因为左闭右开）会议 `j` 的开始时间，即

.. math::

    b_i \leq a_j

两个区间长这样

::

    |----|
         |----|

而根据排序原则，会议 `i - 1` 的结束时间又小于等于会议 `i` 的结束时间，即

.. math::

    b_{i - 1} \leq b_i

所以必定有会议 `i - 1` 的结束时间小于等于会议 `j` 的结束时间，即

.. math::

    b_{i - 1} \leq b_i \leq a_j

所以会议 `i - 1` 和会议 `j` 必然不冲突。

那这个性质有啥用呢？有两个作用。接着看。

设 ``dp[j]`` 为给前 `j` 个会议作安排、并且必须一定要开第 `j - 1` 个会议的条件下，最多能安排的会议的数量。有点拗口，换一种说法，就是以第 `j - 1` 个会议结尾的、最长的互不冲突的会议subsequence（可以不连续）的长度。比如给这几个会议

::

    [1, 2), [2, 3), [1, 3), [3, 4)

以 `[3, 4)` 结尾的最长的互不冲突的subsequence是

::

    [1, 2), [2, 3), [3, 4)

长度是3，而 `[3, 4)` 又是第3个区间，所以 ``dp[4] == 3`` 。

那么怎么算 ``dp[j]`` 呢？首先既然我们已经确定一定要开第 `j - 1` 个会议，所以前面和第 `j - 1` 个会议冲突的会议统统都不能开了，一开就冲突。那怎么办呢？只能先把前面和第 `j - 1` 个会议不冲突的会议都列出来。

这时候我们就发现一开始排序的作用了！如果不排序的话，我们要扫描一遍 ``intervals[0..j - 1]`` ，过滤出所有和会议 `j - 1` 不冲突的会议。然后找到最大的 ``dp[i]`` ，把会议 `j - 1` 接在以会议 `i - 1` 结尾的会议列表的后面。这样做复杂度就是 `O(n^2)` 了，也不差，但是还能做到更快。

如果排序的话，我们就可以找到最靠右的、和会议 `j - 1` 不冲突的会议 `i` ，并且可以保证第0个、第1个、……、第 `i` 个会议都和会议 `j - 1` 不冲突。换句话说，我们可以找到一个边界 `l` ，使得 ``intervals[0..l]`` 里的任意一个会议都和第 `j - 1` 个会议不冲突。那么怎么快速找到这个边界 `l` 呢？这是排序的另一个作用，可以让我们二分搜索。

可是好像还是很慢啊，没变快啊，还是要一个一个找 ``dp[0], dp[1], ..., dp[l]`` 里最大的那个。万一运气不好， `l` 每次都正好等于 `j - 1` ，那岂不是还是 `O(n^2)` 吗？

别急，再给 ``dp`` 建一个累积最大值数组 ``maximums`` ， ``maximums[i] == max(dp[0..i])`` ，这样 ``dp[0], dp[1], ..., dp[l]`` 的最大值就是 ``maximums[l + 1]`` 了！注意是 `l + 1` 。这样复杂度彻底降到 `O(n \ln n)` 了。

.. 这题真的是从暴力一步一步加cache优化的典型了。
*/

struct Solution;

impl Solution {
    // 其实还有贪心做法，然而不好理解，也不好证明，不管了
    #[cfg(feature = "greedy")]
    pub fn erase_overlap_intervals(intervals: Vec<Vec<i32>>) -> i32 {}

    // 虽然以前学过最长不冲突时间序列的DP做法，但是这次换了个dp[i]的含义，我觉得也很好
    #[cfg(feature = "dp")]
    pub fn erase_overlap_intervals(intervals: Vec<Vec<i32>>) -> i32 {
        let mut intervals = intervals;
        intervals.sort_by_key(|v| v[1]); // 先把区间都按结束时间从小到大排序，这样才满足单调性：如果任务i和任务j兼容，那么任务i和任务i之前的所有任务都一定和任务j兼容（因为任务i - 1的结束时间更小，结束得更早，所以更不可能和任务j冲突了）
        let mut dp = vec![0; intervals.len() + 1]; // dp[i]表示安排完前i个任务、并且必须一定安排第i - 1个任务时，最长的、不冲突时间区间序列的长度。也可以理解为以第i - 1个任务结尾的、最长的、不冲突时间区间subsequence的长度
        let mut maximums = vec![0; dp.len() + 1]; // maximums[i]表示dp[0..i]里的最大值

        for j in 1..intervals.len() + 1 {
            // 安排第j - 1个任务
            let start = intervals[j - 1][0]; // 第j - 1个任务的开始时间
            // let end = intervals[j - 1][1]; // 并不需要用到结束时间

            // 找到结束时间最晚的、和第j - 1个任务兼容的任务i，这样就能保证第i、i - 1、i - 2、...、0个任务都和第j - 1个任务兼容
            // 当然不是找到那个任务的下标，而是找到插入位置
            let mut left = 0;
            let mut right = j - 1;

            while left < right {
                let middle = (left + right) / 2;
                if start > intervals[middle][1] {
                    left = middle + 1;
                } else if start < intervals[middle][1] {
                    right = middle;
                } else {
                    left = middle + 1;
                }
            }
            // 到这里intervals[0..left]里每个任务都和第j - 1个任务不冲突

            // 因为一定要安排第j - 1个任务，所以把第j - 1个任务接在以intervals[0..left]里任意一个区间为结尾的subsequence后面，然而并不是接在intervals[0..left]里随便哪个区间的后面就是最优的，接在已经是最长的subsequence的后面才是最长的
            // 所以需要取dp[0], dp[1], ..., dp[left - 1], dp[left]最大的那个，也就是dp[0..left + 1]里最大的数。注意是left + 1
            // dp[j] = &dp[0..left + 1].iter().cloned().max().unwrap_or(0) + 1; // 因为需要知道dp[0..left + 1]里的最大值，所以用一个累积最大值序列做缓存，直接就可以知道dp[0..left + 1]里的最大值
            dp[j] = maximums[left + 1] + 1; // 注意是left + 1
            maximums[j + 1] = maximums[j].max(dp[j]);
        }

        return (intervals.len() - dp.iter().cloned().max().unwrap_or(0)) as i32;
    }
}

fn main() {
    dbg!(Solution::erase_overlap_intervals(vec![
        vec![1, 2],
        vec![2, 3],
        vec![3, 4],
        vec![1, 3],
    ])); // 1
    dbg!(Solution::erase_overlap_intervals(vec![
        vec![1, 2],
        vec![1, 2],
        vec![1, 2],
    ])); // 2
    dbg!(Solution::erase_overlap_intervals(vec![
        vec![1, 2],
        vec![2, 3],
    ])); // 0
}
