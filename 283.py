"""
.. default-role:: math

把array里所有的 ``0`` 全部移动到array的后面。不能用额外空间，要求 `O(n)` 时间。

能想出这个问题我超级激动，当时激动了一个下午hhh。

是所谓的 `荷兰国旗问题 <https://en.wikipedia.org/wiki/Dutch_national_flag_problem>`_ 的简化版。复杂版见75。

但是我不喜欢荷兰国旗这个比喻，自己想的时候，想到了荷叶上的水滴：大水滴一边滑动、一边吸收小水滴。在这个问题里面，我们只要保证

-   水滴里面全是 ``0``
-   水滴最后移动到了array的最后方

就可以了。看个例子，比如

::

    0, 1, 0, 3, 12

怎么搞呢？用一个 ``left`` 来标记水滴左边界（左闭）， ``right`` 标记水滴的右边界（右开）。一开始水滴里什么也没有

::

     0, 1, 0, 3, 12
    |               left
    |               right

发现水滴的右边第一个元素就是 ``0`` ，那么当然要吸收到水滴里面来

::

     0, 1, 0, 3, 12
    |  |

发现水滴的右边第一个元素不是 ``0`` ，怎么办？交换位置水滴的第一个元素和右边这个元素就好了。有点像过河拆桥，一边搭桥一边拆掉后面的桥。

::

     1, 0, 0, 3, 12
    |  |

水滴边界要更新一下，因为通过交换，水滴实际上已经往右移动了一格了

::

     1, 0, 0, 3, 12
       |  |

又遇到 ``0`` 了，吸收

::

     1, 0, 0, 3, 12
       |     |

又遇到非 ``0`` 了，还是交换

::

     1, 3, 0, 0, 12
       |     |

更新边界

::

     1, 3, 0, 0, 12
          |     |

又遇到非 ``0`` 了，交换

::

     1, 3, 12, 0, 0
          |      |

更新边界

::

     1, 3, 12, 0, 0
              |    |

发现水滴已经走到最右边了，完成！

其实想成搭桥问题也可以。河里有一些漂浮的木板（就是 ``0`` ）和一些障碍物（所有非 ``0`` 的元素）。搭桥的时候，如果前面正好是木板，就用木板延伸现在的桥，如果前面是障碍物，就把障碍物和现在桥的最后一块木板交换一下。
"""

from typing import *


class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if len(nums) >= 1:
            left = 0 # 水滴的左边界。左闭
            right = 0 # 水滴的右边界。右开

            while right < len(nums):
                if nums[right] == 0: # 遇到0
                    right += 1 # 吸收
                elif nums[right] != 0: # 遇到非0
                    nums[left], nums[right] = nums[right], nums[left] # 把右边的非0数和水滴的第一个数字交换位置
                    left += 1
                    right += 1 # 更新水滴边界

        else:
            return