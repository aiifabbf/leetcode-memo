"""
给一个set，里面的元素都是数对 :math:`(a_i, b_i)` ，其中 :math:`a_i` 是人的高度、 :math:`b_i` 是这个人前面身高大于等于他的人数。把这个set排好序，使得里面的每个数对都放对位置。

首先肯定是把最高的人挑出来。注意最高的人可能有多个，没关系，按 `b_i` 从小到大排好就行了。

接下来再把第二高的人全部挑出来，也有可能有多个，这样先取 `b_i` 大的还是小的就是一个问题了。经过试验，应该先取 `b_i` 小的。看这个例子

::

    (7, 0), (4, 4), (7, 1), (5, 0), (6, 1), (5, 2)

到

::

    (7, 0), (6, 1), (7, 1)

的时候，还剩下

::

    (4, 4), (5, 0), (5, 2)

此时挑出 ``(5, 0), (5, 2)`` ，如果选择先放 ``(5, 2)`` 的话，

::

    (7, 0), (6, 1), (5, 2), (7, 1)
                    ^^^^^^

再放 ``(5, 0)`` 之后

::

    (5, 0), (7, 0), (6, 1), (5, 2), (7, 1)
    ^^^^^^                  ^^^^^^

会发现 ``(5, 2)`` 的位置就错了。

如果先放 ``(5, 0)`` 就不会有这个问题，

::

    (5, 0), (7, 0), (6, 1), (7, 1)
    ^^^^^^

    (5, 0), (7, 0), (5, 2), (6, 1), (7, 1)
    ^^^^^^          ^^^^^^

所以思路很简单

1.  挑出队列里 `a_i` 最大的元素，如果有多个，先挑出 `b_i` 最小的那个
2.  把挑出来的这个 `(a_i, b_i)` 插入到下标是 `b_i` 的位置上
3.  不停地重复步骤1，直到队列里面没有元素为止

这种做法的复杂度是 `O(n^2)` ，因为每次都要扫描一遍队列，挑出最大的元素。可以做一个非常简单优化，就是直接先把队列按 `a_i` 从小到大、 `b_i` 从大到小排列一下，这样步骤1里挑最大元素的这个操作，就变成了直接把队列尾部的元素pop出来就行了。

这样复杂度就是 `O(n \ln n)` 了。不过其实list的插入操作复杂度是 `O(n)` ……
"""

from typing import *

class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        sortedPeople = sorted(people, key=lambda v: (v[0], -v[1])) # 用custom key，按v[0]从小到大、v[1]从大到小排列
        res = []

        while sortedPeople: # 直到队列里没有元素
            person = sortedPeople.pop() # 挑出a_i最大、b_i最小的元素
            res.insert(person[1], person) # 直接插入到b_i位置上

        return res

# s = Solution()
# print(s.reconstructQueue([[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]))