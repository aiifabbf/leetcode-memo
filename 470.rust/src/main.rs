/*
.. default-role:: math

用 ``rand7()`` 实现 ``rand10()`` 。

``rand7()`` 会返回均匀分布的 `[1, 7]` 中的整数，现在要用它实现返回均匀分布的 `[1, 10]` 中的整数的 ``rand10()`` 。

面美团的时候被问了这道题。当时我想的做法是，先把 ``rand7()`` 退化到 ``rand2()`` 和 ``rand5()`` ，把 ``rand2()`` 的结果作为标志位，如果 ``rand2()`` 返回1，那么就直接返回 ``rand5()`` ，如果 ``rand2()`` 返回2，那么返回 ``rand5() * 2`` 。这样似乎是可以做到均匀分布的。但是调用 ``rand7()`` 的次数可能会很多：

-   ``rand7()`` 退化到 ``rand5()`` 的时候是随机采样，如果发现抽到大于5的数，就再来一次

    那么只调用 ``rand7()`` 一次的概率是 `{5 \over 7}` ，调用两次的概率是 `(1 - {5 \over 7}) \cdot {5 \over 7}` ……调用 `k` 次的概率是 `\left(1 - {5 \over 7}\right)^{k - 1} \cdot {5 \over 7}` 。

    所以调用 ``rand7()`` 次数的期望是

    .. math::

        \sum_{k = 1}^{+\infty} k \cdot \left(1 - {5 \over 7}\right)^{k - 1} \cdot {5 \over 7} = {7 \over 5}

-   ``rand7()`` 退化到 ``rand2()`` 有巧妙的方法，可以先退化到 ``rand6()`` ，然后再模除2

    那么调用 `k` 次的概率是 `\left(1 - {6 \over 7}\right)^{k - 1} \cdot {6 \over 7}` 。

    所以调用 ``rand7()`` 次数的期望是

    .. math::

        \sum_{k = 1}^{+\infty} k \cdot \left(1 - {6 \over 7}\right)^{k - 1} \cdot {6 \over 7} = {7 \over 6}

所以调用 ``rand7()`` 次数的期望值是 `{7 \over 5} + {7 \over 5} = {77 \over 30} \approx 2.6` 次

面完看了题解，发现一个更妙的做法。因为 `10 > 7` ，所以要抛至少两次色子，抛两次总共有49种结果

-   1, 1
-   1, 2
-   1, 3
-   1, ...
-   1, 7
-   2, 1
-   2, 2
-   2, ...
-   ..., ...
-   7, 7

现在的问题就是怎样把这49种结果均匀映射到 `[1, 10]` 。还是用退化。把前40种组合映射到 `[1, 10]` 很简单，假设第一次抛色子得到 `i` ，第二次得到 `j` ，那么 `(((i - 1) \cdot 7 + (j - 1)) \mod 10) + 1` 就好了；如果发现不是前40种组合，就再来一次。

可以看到式子还是挺复杂的，这是因为模除对从0开始的 `[0, 7)` 比较友好，所以不如规定色子的采样结果是 `0, 1, 2, 3, 4, 5, 6` 而不是 `1, 2, 3, 4, 5, 6, 7` 。那么写成 `(7i + j) \mod 10` 就好了。

.. leetcode的 ``rand7()`` 还有bug，只能输出 `[1, 6]` ……
*/

struct Solution;

/**
 * The rand7() API is already defined for you.
 * @return a random integer in the range 1 to 7
 * fn rand7() -> i32;
 */

impl Solution {
    pub fn rand10() -> i32 {
        loop {
            let i = rand7() - 1; // 第一次抛到哪个面
            let j = rand7() - 1; // 第二次抛到哪个面
            let linear = i * 7 + j; // 映射到[0, 49)
            if linear < 40 {
                return linear % 10 + 1; // [0, 40)映射到[1, 11)
            }
            // 如果不在范围内，再试一次就好了
        }
    }
}

fn rand7() -> i32 {
    return 7;
}

fn main() {}
